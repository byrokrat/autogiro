//<?php
/**
 * This file is part of byrokrat\autogiro.
 *
 * byrokrat\autogiro is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat\autogiro is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat\autogiro. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016-18 Hannes Forsgård
 */

namespace byrokrat\autogiro\Parser;

use byrokrat\autogiro\Exception\ContentException;
use byrokrat\autogiro\Tree\AutogiroFile;
use byrokrat\autogiro\Tree\Container;
use byrokrat\autogiro\Tree\Count;
use byrokrat\autogiro\Tree\Date;
use byrokrat\autogiro\Tree\Flag;
use byrokrat\autogiro\Tree\ImmediateDate;
use byrokrat\autogiro\Tree\Interval;
use byrokrat\autogiro\Tree\Message;
use byrokrat\autogiro\Tree\Number;
use byrokrat\autogiro\Tree\Obj;
use byrokrat\autogiro\Tree\Record;
use byrokrat\autogiro\Tree\Section;
use byrokrat\autogiro\Tree\Summary;
use byrokrat\autogiro\Tree\Text;

grammar Grammar extends MultibyteHack
{
    start FILE = RESET_LINE_COUNT file:(REQUEST_FILE / MANDATE_FILE / PAYMENT_FILE / PAYMENT_REJECTION_FILE / AMENDMENT_FILE) VOID {
        return $file;
    };

    RESET_LINE_COUNT = '' {
        $this->lineNr = 1;
    };

    //
    // REQUEST LAYOUTS
    //

    REQUEST_FILE = sections:(REQ_MANDATE_SECTION / REQ_PAYMENT_SECTION / REQ_AMENDMENT_SECTION)+ {
        return new AutogiroFile('AutogiroRequestFile', ...$sections);
    };

    REQ_OPENING = '01' date:DATE8 'AUTOGIRO' S20 S20 S4 bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    // MANDATE REQUESTS

    REQ_MANDATE_SECTION = open:REQ_OPENING records:(REQ_DEL_MANDATE / REQ_REJECT_MANDATE / REQ_CREATE_MANDATE / REQ_UPDATE_MANDATE)+ {
        return new Section('MandateRequestSection', $open, ...$records);
    };

    REQ_DEL_MANDATE = '03' bg:BANKGIRO payerNr:PAYER_NR EOR {
        return new Record('DeleteMandateRequest', $bg, $payerNr);
    };

    REQ_REJECT_MANDATE = '04' bg:BANKGIRO payerNr:PAYER_NR TXT48 'AV' EOR {
        return new Record('RejectDigitalMandateRequest', $bg, $payerNr);
    };

    REQ_CREATE_MANDATE = '04' bg:BANKGIRO payerNr:PAYER_NR account:ACCOUNT16? id:ID? EOR {
        return $id && trim($id->getChild('Number')->getValue())
            ? new Record('CreateMandateRequest', $bg, $payerNr, $account, $id)
            : new Record('AcceptDigitalMandateRequest', $bg, $payerNr);
    };

    REQ_UPDATE_MANDATE = '05' oldBg:BANKGIRO oldPayerNr:PAYER_NR newBg:BANKGIRO newPayerNr:PAYER_NR EOR {
        return new Record('UpdateMandateRequest', $oldBg, $oldPayerNr, $newBg, $newPayerNr);
    };

    // PAYMENT REQUESTS

    REQ_PAYMENT_SECTION = open:REQ_OPENING records:REQ_PAYMENT+ {
        return new Section('PaymentRequestSection', $open, ...$records);
    };

    REQ_PAYMENT = tc:('82' / '32') date:(IMMEDIATE_DATE / DATE8) ival:INTERVAL reps:REPS ' ' payerNr:PAYER_NR amount:AMOUNT12 bg:BANKGIRO ref:VAR_TXT EOR {
        $types = [
            '82' => 'IncomingPaymentRequest',
            '32' => 'OutgoingPaymentRequest',
        ];

        return new Record($types[$tc], $date, $ival, $reps, $payerNr, $amount, $bg, $ref);
    };

    // AMENDMENT REQUESTS

    REQ_AMENDMENT_SECTION = open:REQ_OPENING records:REQ_REVOCATION+ {
        return new Section('AmendmentRequestSection', $open, ...$records);
    };

    REQ_REVOCATION = &('2' [3-9]) tc:MSG2 bg:BANKGIRO payerNr:PAYER_NR date:DATE8 amount:AMOUNT12 type:MSG2 newDate:DATE8 ref:TXT16 EOR {
        $tc->setAttribute('message_id', 'AutogiroRequestFile.TC.' . $tc->getValue());
        $newDate->setName('NewDate');
        return new Record('AmendmentRequest', $tc, $bg, $payerNr, $date, $amount, $type, $newDate, $ref);
    };

    //
    // PAYMENT RESPONSES
    //

    PAYMENT_FILE = NEW_PAYMENT_FILE / OLD_PAYMENT_FILE / BGMAX_FILE;

    NEW_PAYMENT_FILE = open:PAYMENT_OPENING sections:(PAYMENT_INCOMING_SECTION / PAYMENT_OUTGOING_SECTION / PAYMENT_REFUND_SECTION)+ close:PAYMENT_CLOSING {
        $sections[] = $close;
        return new AutogiroFile('AutogiroPaymentResponseFile', $open, ...$sections);
    };

    PAYMENT_OPENING = '01' 'AUTOGIRO' S10 S4 date:DATE20 'BET. SPEC & STOPP TK' ^ bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    PAYMENT_CLOSING = '09' date:DATE8 '9900' nrInSecs:INT6 nrInRecs:INT12 nrOutSecs:INT6 nrOutRecs:INT12 nrRefSecs:INT6 nrRefRecs:INT12 EOR {
        return new Record(
            'Closing',
            $date,
            new Count('IncomingPaymentResponseSection', $nrInSecs),
            new Count('SuccessfulIncomingPaymentResponse', $nrInRecs),
            new Count('OutgoingPaymentResponseSection', $nrOutSecs),
            new Count('SuccessfulOutgoingPaymentResponse', $nrOutRecs),
            new Count('RefundPaymentResponseSection', $nrRefSecs),
            new Count('RefundPaymentResponse', $nrRefRecs)
        );
    };

    // INCOMING PAYMENTS

    PAYMENT_INCOMING_SECTION = open:PAYMENT_INCOMING_OPENING records:(PAYMENT_INCOMING)* {
        return new Section('IncomingPaymentResponseSection', $open, ...$records);
    };

    PAYMENT_INCOMING_OPENING = '15' account:ACCOUNT35 date:DATE8 serial:INT5 amount:AMOUNT18 A2 A nrRecs:INT8 EOR {
        $nrRecs->setName('IncomingPaymentCount');
        return new Record('IncomingPaymentResponseSectionOpening', $account, $date, $serial, $amount, $nrRecs);
    };

    PAYMENT_INCOMING = '82' date:DATE8 ival:INTERVAL reps:REPS A payerNr:PAYER_NR amount:AMOUNT12 bg:BANKGIRO ref:TXT16 A10? status:MSG1? EOR {
        if ($status) {
            $status->setAttribute('message_id', 'AutogiroPaymentResponseFile.' . $status->getValue());
        }

        $flag = !$status || $status->getValue() == '0' ? 'Successful' : 'Failed';

        return new Record($flag.'IncomingPaymentResponse', new Flag($flag), $date, $ival, $reps, $payerNr, $amount, $bg, $ref, $status);
    };

    // OUTGOING PAYMENTS

    PAYMENT_OUTGOING_SECTION = open:PAYMENT_OUTGOING_OPENING records:(PAYMENT_OUTGOING)* {
        return new Section('OutgoingPaymentResponseSection', $open, ...$records);
    };

    PAYMENT_OUTGOING_OPENING = '16' account:ACCOUNT35 date:DATE8 serial:INT5 amount:AMOUNT18 A2 A nrRecs:INT8 EOR {
        $nrRecs->setName('IncomingPaymentCount');
        return new Record('OutgoingPaymentResponseSectionOpening', $account, $date, $serial, $amount, $nrRecs);
    };

    PAYMENT_OUTGOING = '32' date:DATE8 ival:INTERVAL reps:REPS A payerNr:PAYER_NR amount:AMOUNT12 bg:BANKGIRO ref:TXT16 A10? status:MSG1? EOR {
        if ($status) {
            $status->setAttribute('message_id', 'AutogiroPaymentResponseFile.' . $status->getValue());
        }

        $flag = !$status || $status->getValue() == '0' ? 'Successful' : 'Failed';

        return new Record($flag.'OutgoingPaymentResponse', new Flag($flag), $date, $ival, $reps, $payerNr, $amount, $bg, $ref, $status);
    };

    // REFUND PAYMENTS

    PAYMENT_REFUND_SECTION = open:PAYMENT_REFUND_OPENING records:(PAYMENT_REFUND)* {
        return new Section('RefundPaymentResponseSection', $open, ...$records);
    };

    PAYMENT_REFUND_OPENING = '17' account:ACCOUNT35 date:DATE8 serial:INT5 amount:AMOUNT18 A2 A nrRecs:INT8 EOR {
        $nrRecs->setName('IncomingPaymentCount');
        return new Record('RefundPaymentResponseSectionOpening', $account, $date, $serial, $amount, $nrRecs);
    };

    PAYMENT_REFUND = '77' date:DATE8 ival:INTERVAL reps:REPS A payerNr:PAYER_NR amount:AMOUNT12 bg:BANKGIRO ref:TXT16 refundDate:DATE8 status:MSG2 EOR {
        $status->setAttribute('message_id', 'AutogiroPaymentResponseFile.' . $status->getValue());
        $refundDate->setName('RefundDate');
        return new Record('RefundPaymentResponse', $date, $ival, $reps, $payerNr, $amount, $bg, $ref, $refundDate, $status);
    };

    // PAYMENT RESPONSES IN THE OLD FORMAT

    OLD_PAYMENT_FILE = open:OLD_PAYMENT_OPENING recs:OLD_PAYMENT_RESPONSE* close:OLD_PAYMENT_CLOSING {
        $recs[] = $close;
        return new AutogiroFile('AutogiroPaymentResponseOldFile', $open, ...$recs);
    };

    OLD_PAYMENT_OPENING = '01' date:DATE8 'AUTOGIRO' '9900' S20 S20 bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    OLD_PAYMENT_RESPONSE = type:('32' / '82') date:DATE8 ival:INTERVAL reps:REPS A payerNr:PAYER_NR amount:AMOUNT12 bg:BANKGIRO ref:TXT16 A10? status:MSG1? EOR {
        $flag = 'Successful';

        if ($status) {
            $status->setAttribute('message_id', 'AutogiroPaymentResponseFile.' . $status->getValue());
            if ($status->getValue() != '0') {
                $flag = 'Failed';
            }
        }

        $types = [
            '32' => 'OutgoingPaymentResponse',
            '82' => 'IncomingPaymentResponse'
        ];

        return new Record($types[$type], new Flag($flag), $date, $ival, $reps, $payerNr, $amount, $bg, $ref, $status);
    };

    OLD_PAYMENT_CLOSING = '09' date:DATE8 '9900' S10 S4 amountOut:AMOUNT12 nrOut:INT6 nrIn:INT6 '0000' amountIn:AMOUNT12 EOR {
        return new Record(
            'Closing',
            $date,
            new Summary('OutgoingPaymentResponse', $amountOut),
            new Count('OutgoingPaymentResponse', $nrOut),
            new Count('IncomingPaymentResponse', $nrIn),
            new Summary('IncomingPaymentResponse', $amountIn)
        );
    };

    // PAYMENT RESPONSES IN BGMAX FORMAT (NOT SUPPORTED)

    BGMAX_FILE = '01BGMAX' {
        throw new ContentException(['BGMAX format currently not supported']);
    };

    //
    // MANDATE RESPONSES
    //

    MANDATE_FILE = open:(OLD_MANDATE_OPENING / MANDATE_OPENING) mands:MANDATE* close:MANDATE_CLOSING {
        $mands[] = $close;
        return new AutogiroFile('AutogiroMandateResponseFile', $open, ...$mands);
    };

    MANDATE_OPENING = '01' 'AUTOGIRO' S10 S4 date:DATE8 S10 '  AG-MEDAVI' ^ S10 S bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    OLD_MANDATE_OPENING = '01' date:DATE8 '9900' bg:BANKGIRO 'AG-MEDAVI' ^ EOR {
        return new Record('Opening', $date, $bg);
    };

    MANDATE = '73' bg:BANKGIRO payerNr:PAYER_NR account:ACCOUNT16 id:ID (S5 / '00000') info:MSG2 status:MSG2 date:DATE8 validDate:DATE6? EOR {
        // If account is empty a valid bankgiro number may be read from the payer number field
        if (!trim($account->getChild('Number')->getValue())) {
            $account = new Container('Account', new Number($account->getLineNr(), $payerNr->getValue()));
        }

        $info->setAttribute('message_id', "73.info.{$info->getValue()}");
        $status->setAttribute('message_id', "73.status.{$status->getValue()}");

        $validDate->setName('ValidFromDate');

        return new Record('MandateResponse', $bg, $payerNr, $account, $id, $info, $status, $date, $validDate);
    };

    MANDATE_CLOSING = '09' date:DATE8 '9900' nrRecs:INT7 EOR {
        return new Record('Closing', $date, new Count('MandateResponse', $nrRecs));
    };

    //
    // REJECTED PAYMENT RESPONSE
    //

    PAYMENT_REJECTION_FILE = open:(PAYMENT_REJECTION_OPENING / OLD_PAYMENT_REJECTION_OPENING) recs:PAYMENT_REJECTION* close:PAYMENT_REJECTION_CLOSING {
        $recs[] = $close;
        return new AutogiroFile('AutogiroPaymentRejectionFile', $open, ...$recs);
    };

    PAYMENT_REJECTION_OPENING = '01' 'AUTOGIRO' S10 S4 date:DATE8 S10 '  AVVISADE BET UPPDR  ' ^ bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    OLD_PAYMENT_REJECTION_OPENING = '01' date:DATE8 'AUTOGIRO' '9900' 'FELLISTA REG.KONTRL' ^ S20 S bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    PAYMENT_REJECTION = tc:('82' / '32') date:DATE8 ival:INTERVAL reps:REPS payerNr:PAYER_NR amount:AMOUNT12 ref:TXT16 comment:MSG2 EOR {
        $types = [
            '82' => 'IncomingPaymentRejectionResponse',
            '32' => 'OutgoingPaymentRejectionResponse',
        ];

        return new Record($types[$tc], $date, $ival, $reps, $payerNr, $amount, $ref, $comment);
    };

    PAYMENT_REJECTION_CLOSING = '09' date:DATE8 '9900' nrOut:INT6 amountOut:AMOUNT12 nrIn:INT6 amountIn:AMOUNT12 EOR {
        return new Record(
            'Closing',
            $date,
            new Count('OutgoingPaymentRejectionResponse', $nrOut),
            new Summary('OutgoingPaymentRejectionResponse', $amountOut),
            new Count('IncomingPaymentRejectionResponse', $nrIn),
            new Summary('IncomingPaymentRejectionResponse', $amountIn)
        );
    };

    //
    // AMENDMENT RESPONSES
    //

    // TODO flytta till annat ställe och använd för alla openings om jag får det att funka...
    OPENING_INTRO = '01AUTOGIRO              ' date:DATE8 '            ' {
        return $date;
    };

    // TODO flytta till annat ställe och använd för alla openings om jag får det att funka...
    OLD_OPENING_INTRO = '01' date:DATE8 'AUTOGIRO9900' {
        return $date;
    };

    AMENDMENT_FILE = open:(OLD_AMENDMENT_OPENING / AMENDMENT_OPENING) recs:AMENDMENT* close:AMENDMENT_CLOSING {
        $recs[] = $close;
        return new AutogiroFile('AutogiroAmendmentResponseFile', $open, ...$recs);
    };

    AMENDMENT_OPENING = date:OPENING_INTRO 'MAKULERING/ÄNDRING  ' ^ bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    OLD_AMENDMENT_OPENING = date:OLD_OPENING_INTRO 'MAK/ÄNDRINGSLISTA   ' ^ S20 bgcNr:BGC_NR bg:BANKGIRO EOR {
        return new Record('Opening', $date, $bgcNr, $bg);
    };

    AMENDMENT = !'09' status:MSG2 date:DATE8 payerNr:PAYER_NR type:MSG2 amount:AMOUNT12 A8 A8 ref:TXT16 comment:MSG2 EOR {
        $status->setAttribute('message_id', 'AutogiroAmendmentResponseFile.TC.' . $status->getValue());

        $flag = in_array($status->getValue(), ['26', '27', '28', '29']) ? 'Amendment' : 'Revocation';

        $names = [
            '00' => 'AmendmentResponse',
            '82' => 'IncomingAmendmentResponse',
            '32' => 'OutgoingAmendmentResponse',
        ];

        $namePrefix = in_array($comment->getValue(), ['12', '14', '18']) ? 'Successful' : 'Failed';

        $status->setName('Status');
        $type->setName('Type');
        $ref->setName('Reference');
        $comment->setName('Comment');

        return new Record($namePrefix.$names[$type->getValue()], new Flag($flag), $status, $date, $payerNr, $type, $amount, $ref, $comment);
    };

    AMENDMENT_CLOSING = '09' date:DATE8 '9900' S10 S4 amountOut:AMOUNT12 nrOut:INT6 nrIn:INT6 A4 amountIn:AMOUNT12 EOR {
        return new Record(
            'Closing',
            $date,
            new Summary('SuccessfulOutgoingAmendmentResponse', $amountOut),
            new Count('SuccessfulOutgoingAmendmentResponse', $nrOut),
            new Count('SuccessfulIncomingAmendmentResponse', $nrIn),
            new Summary('SuccessfulIncomingAmendmentResponse', $amountIn)
        );
    };

    //
    // TYPE SYSTEN
    //

    // EXTERNAL TYPES

    ACCOUNT16 = number:$(A10 A5 A) {
        return new Container('Account', new Number($this->lineNr, $number));
    };

    ACCOUNT35 = number:$(A10 A10 A10 A5) {
        return new Container('Account', new Number($this->lineNr, $number));
    };

    AMOUNT12 = amount:$(A10 A2) {
        return new Container('Amount', new Text($this->lineNr, trim($amount)));
    };

    AMOUNT18 = amount:$(A10 A5 A2 A) {
        return new Container('Amount', new Text($this->lineNr, trim($amount)));
    };

    BANKGIRO = number:A10 {
        return new Container('PayeeBankgiro', new Number($this->lineNr, $number));
    };

    ID = number:$(A10 A2) {
        return new Container('StateId', new Number($this->lineNr, trim($number)));
    };

    // SIMPLE TYPES

    BGC_NR = nr:$(A5 A) {
        return new Number($this->lineNr, $nr, 'PayeeBgcNumber');
    };

    DATE6 = date:$(A5 A) {
        return new Date(new Number($this->lineNr, trim($date)));
    };

    DATE8 = date:$(A5 A2 A) {
        return new Date(new Number($this->lineNr, trim($date)));
    };

    DATE20 = date:$(A10 A10) {
        return new Date(new Number($this->lineNr, trim($date)));
    };

    IMMEDIATE_DATE = 'GENAST  ' {
        return new ImmediateDate($this->lineNr);
    };

    INTERVAL = interval:$(A) {
        return new Interval($this->lineNr, $interval);
    };

    MSG1 = msg:$(A) {
        return new Message($this->lineNr, $msg);
    };

    MSG2 = msg:$(A A) {
        return new Message($this->lineNr, $msg);
    };

    PAYER_NR = nr:$(A10 A5 A) {
        return new Number($this->lineNr, trim($nr), 'PayerNumber');
    };

    REPS = repetitions:$(A2 A) {
        return new Number($this->lineNr, trim($repetitions), 'Repetitions');
    };

    // CONVENIENCE TYPES

    INT5 = integer:$(A5) {
        return new Number($this->lineNr, $integer);
    };

    INT6 = integer:$(A5 A) {
        return new Number($this->lineNr, $integer);
    };

    INT7 = integer:$(A5 A2) {
        return new Number($this->lineNr, $integer);
    };

    INT8 = integer:$(A5 A2 A) {
        return new Number($this->lineNr, $integer);
    };

    INT12 = integer:$(A10 A2) {
        return new Number($this->lineNr, $integer);
    };

    VAR_TXT = text:$(A*) {
        return new Text($this->lineNr, $text);
    };

    TXT16 = text:$(A? A? A? A? A? A? A? A? A? A? A? A? A? A? A? A?) {
        return new Text($this->lineNr, $text);
    };

    TXT48 = text:$(A10 A10 A10 A10 A5 A2 A) {
        return new Text($this->lineNr, $text);
    };

    // ALPHA-NUM

    // TODO testar med ett mer tillåtande system..
    //A "ALPHA-NUMERIC" = [a-zA-Z0-9 \/&åäöÅÄÖ-];
    A "ALPHA-NUMERIC" = !EOL .;

    A2 = $(A A);

    A4 = $(A2 A2);

    A5 = $(A A A A A);

    A8 = $(A5 A2 A);

    A10 = $(A5 A5);

    // SPACE

    S "SPACE" = ' ';

    S4 = $(S S S S);

    S5 = $(S4 S);

    S10 = $(S5 S5);

    S20 = $(S10 S10);

    // ENDINGS

    EOR "END_OF_RECORD" = A* (EOL / EOF);

    EOL "END_OF_LINE" = "\r"? "\n" {
        $this->lineNr++;
    };

    EOF "END_OF_FILE" = !.;

    VOID = (S / "\t" / EOL)*;
}
