//<?php
/**
 * This file is part of byrokrat\autogiro.
 *
 * byrokrat\autogiro is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat\autogiro is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat\autogiro. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016 Hannes Forsgård
 */

namespace byrokrat\autogiro;

use byrokrat\autogiro\Exception\ParserException;
use byrokrat\autogiro\Tree\Account;
use byrokrat\autogiro\Tree\AmountNode;
use byrokrat\autogiro\Tree\BgcCustomerNumberNode;
use byrokrat\autogiro\Tree\ClosingNode;
use byrokrat\autogiro\Tree\Date;
use byrokrat\autogiro\Tree\FileNode;
use byrokrat\autogiro\Tree\Id;
use byrokrat\autogiro\Tree\Interval;
use byrokrat\autogiro\Tree\LayoutNode;
use byrokrat\autogiro\Tree\MessageNode;
use byrokrat\autogiro\Tree\OpeningNode;
use byrokrat\autogiro\Tree\PayerNumberNode;
use byrokrat\autogiro\Tree\Record\Request;
use byrokrat\autogiro\Tree\Record\Response;
use byrokrat\autogiro\Tree\Repeats;
use byrokrat\autogiro\Tree\SpaceNode;
use byrokrat\autogiro\Tree\TextNode;

grammar Grammar
{
    start FILE = RESET_LINE_COUNT layout:(L_REQ_CONTAINER / L_RESP_MANDATE) {
        return $layout;
    };

    RESET_LINE_COUNT = '' {
        $this->currentLineNr = 0;
    };

    // GENERIC RECORDS

    R_GENERIC_OPENING = '01' 'AUTOGIRO' S10 S S S S date:DATE S10 S S layout:A20 custNr:CUST_NR bg:BANKGIRO EOR {
        return new OpeningNode($this->currentLineNr, rtrim($layout), $date, $custNr, $bg);
    };

    //
    // REQUEST LAYOUTS
    //

    L_REQ_CONTAINER = layouts:(L_REQ_MANDATE / L_REQ_PAYMENT / L_REQ_AMENDMENT)+ {
        return new FileNode(...$layouts);
    };

    R_REQ_OPENING = '01' date:DATE 'AUTOGIRO' S20 S20 S S S S custNr:CUST_NR bg:BANKGIRO EOR {
        return new OpeningNode($this->currentLineNr, '', $date, $custNr, $bg);
    };

    // MANDATE REQUESTS

    L_REQ_MANDATE = opening:R_REQ_OPENING records:(R_REQ_CREATE_MANDATE / R_REQ_UPDATE_MANDATE / R_REQ_DEL_MANDATE)+ {
        return new LayoutNode(
            $opening->setAttribute('layout_name', Layouts::LAYOUT_MANDATE_REQUEST),
            new ClosingNode($this->currentLineNr, $opening->getChild('date'), count($records)),
            ...$records
        );
    };

    R_REQ_CREATE_MANDATE = '04' bg:BANKGIRO payerNr:PAYER_NR account:ACCOUNT? id:ID? S20? reject:'AV'? EOR {
        if ($reject == 'AV') {
            return new Request\RejectMandateRequestNode($this->currentLineNr, $bg, $payerNr);
        }

        return $account && $id
            ? new Request\CreateMandateRequestNode($this->currentLineNr, $bg, $payerNr, $account, $id)
            : new Request\AcceptMandateRequestNode($this->currentLineNr, $bg, $payerNr);
    };

    R_REQ_UPDATE_MANDATE = '05' oldBg:BANKGIRO oldPayerNr:PAYER_NR newBg:BANKGIRO newPayerNr:PAYER_NR EOR {
        return new Request\UpdateMandateRequestNode($this->currentLineNr, $oldBg, $oldPayerNr, $newBg, $newPayerNr);
    };

    R_REQ_DEL_MANDATE = '03' bg:BANKGIRO payerNr:PAYER_NR EOR {
        return new Request\DeleteMandateRequestNode($this->currentLineNr, $bg, $payerNr);
    };

    // PAYMENT REQUESTS

    L_REQ_PAYMENT = opening:R_REQ_OPENING records:(R_REQ_TRANSACTION)+ {
        return new LayoutNode(
            $opening->setAttribute('layout_name', Layouts::LAYOUT_PAYMENT_REQUEST),
            new ClosingNode($this->currentLineNr, $opening->getChild('date'), count($records)),
            ...$records
        );
    };

    R_REQ_TRANSACTION = tc:('82' / '32') date:(IMMEDIATE_DATE / DATE) interval:INTERVAL repeats:REPEATS void:VOID payerNr:PAYER_NR amount:AMOUNT payeeBg:BANKGIRO ref:TEXT16 end:EOR {
        // TODO processor som kontrollerar att periodkod inte används vid GENAST (se dokument)
        // TODO processor som kontrollerar att interval=0 paras med no repeats (se dokument)

        // TODO fortsätt med nästa argument...
            // nästa är betalningsmottagarens bankgironummer, passa på att göra överallt:
                //Där bankgiro är payee borde jag byta namn på attribute till payee_bankgiro !!
                    // byt även namn på alla lokala variabler osv...
                    // lika bra att göra det tydligt när jag ändå håller på...
                //payee_bgc_customer_nr ?? // eller bara payee_bgc_number ??

        // TODO SpaceNode krävs för att vi ska kunna skriva ut mellanslag...      [KLAR]
        // TODO processor som kontrollerar att SpaceNode innehåller ett space...

        // TODO ska jag skapa abstract Tree\RecordNode? Att använda exempelvis i LayoutNode...
            // Ja, kan även implementera ett visst antal space på slutet på något generellt sätt...
            // EOR kan returnera alla space den hittar i slutet av sträng... (Har jag börjat pilla på...)

        return $tc == '82'
            ? new Request\IncomingTransactionRequestNode($this->currentLineNr, $date, $interval, $repeats, $void, $payerNr, $amount, $payeeBg, $ref, $end)
            : new Request\OutgoingTransactionRequestNode($this->currentLineNr, $date, $interval, $repeats, $void, $payerNr, $amount, $payeeBg, $ref, $end);
    };

    // AMENDMENT REQUESTS

    L_REQ_AMENDMENT = opening:R_REQ_OPENING records:('TODO')+ {
        // TODO this is just a stub...
        return new LayoutNode(
            $opening->setAttribute('layout_name', Layouts::LAYOUT_AMENDMENT_REQUEST),
            new ClosingNode($this->currentLineNr, $opening->getChild('date'), count($records)),
            ...$records
        );
    };

    //
    // RESPONSE LAYOUTS
    //

    // MANDATE RESPONSES

    L_RESP_MANDATE = opening:(R_GENERIC_OPENING / R_RESP_MANDATE_OPENING_OLD) mandates:R_RESP_MANDATE* closing:R_RESP_MANDATE_CLOSING {
        return new FileNode(new LayoutNode($opening, $closing, ...$mandates));
    };

    R_RESP_MANDATE_OPENING_OLD = '01' date:DATE BGC_CLEARING bg:BANKGIRO 'AG-MEDAVI' EOR {
        return new OpeningNode(
            $this->currentLineNr,
            'AG-MEDAVI',
            $date,
            new BgcCustomerNumberNode($this->currentLineNr, ''),
            $bg
        );
    };

    R_RESP_MANDATE = '73' bg:BANKGIRO payerNr:PAYER_NR account:ACCOUNT id:ID A5 info:$(N N) comment:$(N N) date:DATE? EOR {
        $account = $account->getValue()
            ? $account
            : new Account\AccountNode($this->currentLineNr, $payerNr->getValue());

        return new Response\MandateResponseNode(
            $this->currentLineNr,
            $bg,
            $payerNr,
            $account,
            $id,
            new MessageNode($this->currentLineNr, "73.$info"),
            new MessageNode($this->currentLineNr, "73.comment.$comment"),
            $date ?: new Date\DateNode($this->currentLineNr, '@0')
        );
    };

    R_RESP_MANDATE_CLOSING = '09' date:DATE BGC_CLEARING nrOfPosts:$(N5 N N) EOR {
        return new ClosingNode($this->currentLineNr, $date, intval($nrOfPosts));
    };

    // TYPES

    ACCOUNT = number:$(A10 A5 A) {
        return new Account\AccountNode($this->currentLineNr, trim(ltrim($number, '0')));
    };

    AMOUNT = amount:$(A10 A A) {
        return new AmountNode($this->currentLineNr, trim(ltrim($amount, '0')));
    };

    BANKGIRO = number:A10 {
        return new Account\BankgiroNode($this->currentLineNr, trim(ltrim($number, '0')));
    };

    BGC_CLEARING = '9900';

    CUST_NR = nr:$(A5 A) {
        return new BgcCustomerNumberNode($this->currentLineNr, trim(ltrim($nr, '0')));
    };

    DATE = date:$(A5 A A A) {
        return new Date\DateNode($this->currentLineNr, trim($date));
    };

    IMMEDIATE_DATE = 'GENAST' S S {
        return new Date\ImmediateDateNode($this->currentLineNr);
    };

    ID = century:$(A A) number:A10 {
        return in_array($century, ['00', '99'])
            ? new Id\OrganizationIdNode($this->currentLineNr, trim($number))
            : new Id\PersonalIdNode($this->currentLineNr, trim($century.$number));
    };

    INTERVAL = interval:A {
        switch ($interval) {
            case '0': return new Interval\IntervalOnceNode;
            case '1': return new Interval\IntervalMonthlyOnDateNode;
            case '2': return new Interval\IntervalQuarterlyOnDateNode;
            case '3': return new Interval\IntervalSemiannuallyOnDateNode;
            case '4': return new Interval\IntervalAnnuallyOnDateNode;
            case '5': return new Interval\IntervalMonthlyOnLastCalendarDayNode;
            case '6': return new Interval\IntervalQuarterlyOnLastCalendarDayNode;
            case '7': return new Interval\IntervalSemiannuallyOnLastCalendarDayNode;
            case '8': return new Interval\IntervalAnnuallyOnLastCalendarDayNode;
            default: throw new ParserException("Invalid interval identifier $interval");
        }
    };

    PAYER_NR = nr:$(A10 A5 A) {
        return new PayerNumberNode($this->currentLineNr, trim(ltrim($nr, '0')));
    };

    REPEATS = repeats:$(A A A) {
        $repeats = trim(ltrim($repeats, '0'));

        if ($repeats) {
            return new Repeats\RepeatsNode($this->currentLineNr, $repeats);
        }

        return new Repeats\RepeatsUnspecifiedNode($this->currentLineNr);
    };

    // HELPERS

    // TODO should I only use A-helper, and only validate data i processors??

    A "ALPHA-NUMERIC" = [a-zA-Z0-9 -\/&];

    A5 = $(A A A A A);

    A10 = $(A5 A5);

    A20 = $(A10 A10);

    N "NUMBER" = [0-9];

    N5 = $(N N N N N);

    S "SPACE" = ' ';

    S10 = $(S S S S S S S S S S);

    S20 = $(S10 S10);

    // TODO alla S och N (och A?) ska ersättas av void...
    VOID = chars:A {
        return new SpaceNode($this->currentLineNr, $chars);
    };

    VOID10 = chars:A10 {
        return new SpaceNode($this->currentLineNr, $chars);
    };

    VOID20 = chars:A20 {
        return new SpaceNode($this->currentLineNr, $chars);
    };

    TEXT16 = text:$(A10 A5 A) {
        return new TextNode($this->currentLineNr, $text);
    };

    EOR "END_OF_RECORD" = end:VOID* (EOL / EOF) {
        // TODO alla ställen där jag använder EOR ska dessa end voids fångas upp...
        return $end;
    };

    EOL "END_OF_LINE" = "\r"? "\n" {
        $this->currentLineNr++;
    };

    EOF "END_OF_FILE" = !.;
}
