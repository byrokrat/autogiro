//<?php
/**
 * This file is part of byrokrat\autogiro.
 *
 * byrokrat\autogiro is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * byrokrat\autogiro is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with byrokrat\autogiro. If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2016 Hannes Forsgård
 */

namespace byrokrat\autogiro;

use byrokrat\autogiro\Tree\AccountNode;
use byrokrat\autogiro\Tree\AmountNode;
use byrokrat\autogiro\Tree\PayeeBankgiroNode;
use byrokrat\autogiro\Tree\PayeeBgcNumberNode;
use byrokrat\autogiro\Tree\Date;
use byrokrat\autogiro\Tree\FileNode;
use byrokrat\autogiro\Tree\Id;
use byrokrat\autogiro\Tree\Interval;
use byrokrat\autogiro\Tree\LayoutNode;
use byrokrat\autogiro\Tree\MessageNode;
use byrokrat\autogiro\Tree\PayerNumberNode;
use byrokrat\autogiro\Tree\Record\ClosingRecordNode;
use byrokrat\autogiro\Tree\Record\OpeningRecordNode;
use byrokrat\autogiro\Tree\Record\Request;
use byrokrat\autogiro\Tree\Record\Response;
use byrokrat\autogiro\Tree\Repeats;
use byrokrat\autogiro\Tree\TextNode;

grammar Grammar
{
    // TODO Det enda som inte ska vara nodes är transaktionskoder
        // på något sätt måste trotts allt olika record skiljas från varandra vid parse-time..

        // stega igenom filen och kontrollera att det stämmer överallt...

    // TODO lägg till någon form av ErrorNode så att jag om jag skickar in helt
        // felaktig text så får vi trotts allt ett bra felmeddelande
        //
        // lägg ett behat test för detta också...

    start FILE = RESET_LINE_COUNT layout:(REQUEST_FILE / L_RESP_MANDATE) {
        return $layout;
    };

    RESET_LINE_COUNT = '' {
        $this->currentLineNr = 0;
    };

    // GENERIC RECORDS

    R_GENERIC_OPENING = '01' ag:AUTOGIRO space1:VOID14 date:DATE space2:VOID12 layout:TEXT20 payeeBgcNr:BGC_NR payeeBg:PAYEE_BG void:EOR {
        return new OpeningRecordNode($this->currentLineNr, $ag, $space1, $date, $space2, $layout, $payeeBgcNr, $payeeBg, $void);
    };

    //
    // REQUEST LAYOUTS
    //

    REQUEST_FILE = layouts:(L_REQ_MANDATE / L_REQ_PAYMENT / L_REQ_AMENDMENT)+ {
        return new FileNode(...$layouts);
    };

    R_REQ_OPENING = '01' date:DATE ag:AUTOGIRO space:VOID44 payeeBgcNr:BGC_NR payeeBg:PAYEE_BG void:EOR {
        return new Request\RequestOpeningRecordNode($this->currentLineNr, $date, $ag, $space, $payeeBgcNr, $payeeBg, $void);
    };

    // MANDATE REQUESTS

    L_REQ_MANDATE = open:R_REQ_OPENING records:(R_REQ_CREATE_MANDATE / R_REQ_UPDATE_MANDATE / R_REQ_DEL_MANDATE)+ {
        return (new LayoutNode($open, ...$records))->setAttribute('layout_name', Layouts::LAYOUT_MANDATE_REQUEST);
    };

    R_REQ_CREATE_MANDATE = '04' payeeBg:PAYEE_BG payerNr:PAYER_NR account:ACCOUNT? id:ID? space:VOID20? reject:'AV'? void:EOR {
        // TODO $space måste också sparas till objekt för att kunna valideras...

        if ($reject == 'AV') {
            return new Request\RejectMandateRequestNode($this->currentLineNr, $payeeBg, $payerNr, $void);
        }

        return $account && $id
            ? new Request\CreateMandateRequestNode($this->currentLineNr, $payeeBg, $payerNr, $account, $id, $void)
            : new Request\AcceptMandateRequestNode($this->currentLineNr, $payeeBg, $payerNr, $void);
    };

    R_REQ_UPDATE_MANDATE = '05' oldPayeeBg:PAYEE_BG oldPayerNr:PAYER_NR newPayeeBg:PAYEE_BG newPayerNr:PAYER_NR void:EOR {
        return new Request\UpdateMandateRequestNode($this->currentLineNr, $oldPayeeBg, $oldPayerNr, $newPayeeBg, $newPayerNr, $void);
    };

    R_REQ_DEL_MANDATE = '03' payeeBg:PAYEE_BG payerNr:PAYER_NR void:EOR {
        return new Request\DeleteMandateRequestNode($this->currentLineNr, $payeeBg, $payerNr, $void);
    };

    // PAYMENT REQUESTS

    L_REQ_PAYMENT = open:R_REQ_OPENING records:(R_REQ_TRANSACTION)+ {
        return (new LayoutNode($open, ...$records))->setAttribute('layout_name', Layouts::LAYOUT_PAYMENT_REQUEST);
    };

    R_REQ_TRANSACTION = tc:('82' / '32') date:(IMMEDIATE_DATE / DATE) interval:INTERVAL repeats:REPEATS space:VOID payerNr:PAYER_NR amount:AMOUNT payeeBg:PAYEE_BG ref:TEXT16 void:EOR {
        // TODO fixxa dessa processors
            // kontrollerar att periodkod inte används vid GENAST (se dokument)
            // kontrollerar att interval=0 paras med no repeats (se dokument)

        // TODO skriv dessa 2 request-records klara...
        // TODO lägg till behat-test för denna layout
            // så kan jag gå vidare sedan...

        return $tc == '82'
            ? new Request\IncomingTransactionRequestNode($this->currentLineNr, $date, $interval, $repeats, $space, $payerNr, $amount, $payeeBg, $ref, $void)
            : new Request\OutgoingTransactionRequestNode($this->currentLineNr, $date, $interval, $repeats, $space, $payerNr, $amount, $payeeBg, $ref, $void);
    };

    // AMENDMENT REQUESTS

    L_REQ_AMENDMENT = open:R_REQ_OPENING records:('TODO')+ {
        // TODO this is just a stub...
        return (new LayoutNode($open, ...$records))->setAttribute('layout_name', Layouts::LAYOUT_AMENDMENT_REQUEST);
    };

    //
    // RESPONSE LAYOUTS
    //

    // MANDATE RESPONSES

    L_RESP_MANDATE = open:(R_GENERIC_OPENING / R_RESP_MANDATE_OPENING_OLD) mands:R_RESP_MANDATE* close:R_RESP_MANDATE_CLOSING {
        return new FileNode(
            (new LayoutNode($open, $close, ...$mands))->setAttribute('layout_name', Layouts::LAYOUT_MANDATE_RESPONSE)
        );
    };

    R_RESP_MANDATE_OPENING_OLD = '01' date:DATE clear:$(A2 A2) payeeBg:PAYEE_BG layout:$(A5 A2 A2) void:EOR {
        return new OpeningRecordNode(
            $this->currentLineNr,
            new TextNode($this->currentLineNr, ''),
            new TextNode($this->currentLineNr, ''),
            $date,
            new TextNode($this->currentLineNr, $clear, '/^9900$/'),
            new TextNode($this->currentLineNr, $layout, '/^AG-MEDAVI$/'),
            new PayeeBgcNumberNode($this->currentLineNr, ''),
            $payeeBg,
            $void
        );
    };

    R_RESP_MANDATE = '73' payeeBg:PAYEE_BG payerNr:PAYER_NR account:ACCOUNT id:ID A5 info:$(A A) comment:$(A A) date:DATE? validDate:$(A5 A)? void:EOR {
        $account = $account->getValue()
            ? $account
            : new AccountNode($this->currentLineNr, $payerNr->getValue());

        // TODO här oven finns en A5 som måste sparas...

        // TODO $validDate måste sparas, se s 78 i specen, det är datum då medgivandet är giltigt för debitering..
            // dock bara sex siffror, så det är inte riktigt som det vanliga date...

        return new Response\MandateResponseNode(
            $this->currentLineNr,
            $payeeBg,
            $payerNr,
            $account,
            $id,
            new MessageNode($this->currentLineNr, "73.$info"),
            new MessageNode($this->currentLineNr, "73.comment.$comment"),
            $date ?: new Date\DateNode($this->currentLineNr, '@0'),
            $void
        );
    };

    R_RESP_MANDATE_CLOSING = '09' date:DATE clear:$(A2 A2) nrOfPosts:INT7 void:EOR {
        // TODO clearing måste sparas så att det kan valideras...
        new TextNode($this->currentLineNr, $clear, '/^9900$/');

        return new ClosingRecordNode($this->currentLineNr, $date, $nrOfPosts, $void);
    };

    // TYPES

    ACCOUNT = number:$(A10 A5 A) {
        return new AccountNode($this->currentLineNr + 1, $number);
    };

    AMOUNT = amount:$(A10 A A) {
        return new AmountNode($this->currentLineNr + 1, $amount);
    };

    AUTOGIRO = text:$(A5 A A A) {
        return new TextNode($this->currentLineNr + 1, $text, '/^AUTOGIRO$/');
    };

    PAYEE_BG = number:A10 {
        return new PayeeBankgiroNode($this->currentLineNr + 1, $number);
    };

    BGC_NR = nr:$(A5 A) {
        return new PayeeBgcNumberNode($this->currentLineNr + 1, $nr);
    };

    DATE = date:$(A5 A A A) {
        return new Date\DateNode($this->currentLineNr + 1, $date);
    };

    IMMEDIATE_DATE = 'GENAST  ' {
        return new Date\ImmediateDateNode($this->currentLineNr + 1);
    };

    ID = century:$(A A) number:A10 {
        return in_array($century, ['00', '99'])
            ? new Id\OrganizationIdNode($this->currentLineNr + 1, $number)
            : new Id\PersonalIdNode($this->currentLineNr + 1, $century.$number);
    };

    INTERVAL = interval:A {
        switch ($interval) {
            case '0': return new Interval\IntervalOnceNode($this->currentLineNr + 1, $interval);
            case '1': return new Interval\IntervalMonthlyOnDateNode($this->currentLineNr + 1, $interval);
            case '2': return new Interval\IntervalQuarterlyOnDateNode($this->currentLineNr + 1, $interval);
            case '3': return new Interval\IntervalSemiannuallyOnDateNode($this->currentLineNr + 1, $interval);
            case '4': return new Interval\IntervalAnnuallyOnDateNode($this->currentLineNr + 1, $interval);
            case '5': return new Interval\IntervalMonthlyOnLastCalendarDayNode($this->currentLineNr + 1, $interval);
            case '6': return new Interval\IntervalQuarterlyOnLastCalendarDayNode($this->currentLineNr + 1, $interval);
            case '7': return new Interval\IntervalSemiannuallyOnLastCalendarDayNode($this->currentLineNr + 1, $interval);
            case '8': return new Interval\IntervalAnnuallyOnLastCalendarDayNode($this->currentLineNr + 1, $interval);

            // TODO ska jag verkligen kasta undantag här? Ska inte det göras i processor??
                // default kan vara att göra once, och så kan jag i processor kontrollera innehållet i IntervalOnceNode...
            default: throw new \byrokrat\autogiro\Exception\ParserException(["Invalid interval identifier $interval"]);
        }
    };

    PAYER_NR = nr:$(A10 A5 A) {
        return new PayerNumberNode($this->currentLineNr + 1, $nr);
    };

    REPEATS = repeats:$(A A A) {
        // TODO här vill jag egentligen inte använda trim
            // men måste kolla lite mer i dokumentationen innan jag tar bort...

        $repeats = trim(ltrim($repeats, '0'));

        if ($repeats) {
            return new Repeats\RepeatsNode($this->currentLineNr + 1, $repeats);
        }

        return new Repeats\RepeatsUnspecifiedNode($this->currentLineNr + 1);
    };

    // CONVENIENCE TYPES

    INT7 = integer:$(A5 A2) {
        return new TextNode($this->currentLineNr + 1, $integer, '/^\d{7}$/');
    };

    TEXT16 = text:$(A10 A5 A) {
        return new TextNode($this->currentLineNr + 1, $text);
    };

    TEXT20 = text:$(A10 A10) {
        return new TextNode($this->currentLineNr + 1, $text);
    };

    VOID = text:$(A) {
        return new TextNode($this->currentLineNr + 1, $text, '/^ $/');
    };

    VOID10 = text:$(A10) {
        return new TextNode($this->currentLineNr + 1, $text, '/^ {10}$/');
    };

    VOID12 = text:$(A10 A2) {
        return new TextNode($this->currentLineNr + 1, $text, '/^ {12}$/');
    };

    VOID14 = text:$(A10 A2 A2) {
        return new TextNode($this->currentLineNr + 1, $text, '/^ {14}$/');
    };

    VOID20 = text:$(A10 A10) {
        return new TextNode($this->currentLineNr + 1, $text, '/^ {20}$/');
    };

    VOID44 = text:$(A10 A10 A10 A10 A2 A2) {
        return new TextNode($this->currentLineNr + 1, $text, '/^ {44}$/');
    };

    // HELPERS

    A "ALPHA-NUMERIC" = [a-zA-Z0-9 -\/&];

    A2 = $(A A);

    A5 = $(A A A A A);

    A10 = $(A5 A5);

    // ENDINGS

    EOR "END_OF_RECORD" = void:VOID* (EOL / EOF) {
        return $void;
    };

    EOL "END_OF_LINE" = "\r"? "\n" {
        $this->currentLineNr++;
    };

    EOF "END_OF_FILE" = !.;
}
